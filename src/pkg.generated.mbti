// Generated using `moon info`, DON'T EDIT IT
package "mizchi/jsonschema"

import(
  "moonbitlang/core/json"
  "moonbitlang/core/set"
)

// Values
fn build_resolver(Json) -> Resolver raise ParseError

fn build_validator(Json) -> Validator raise

fn collect_refs(Json) -> @set.Set[String]

// Errors
pub suberror ParseError {
  JsonDecodeError(@json.JsonDecodeError)
  PointerParseError(String)
}

pub suberror RuntimeError {
  Unsupported(String)
}

// Types and methods
pub struct Builder {
}
fn Builder::allOf(Self, Array[JsonSchema]) -> JsonSchema
fn Builder::any(Self, description? : String) -> JsonSchema
fn Builder::anyOf(Self, Array[JsonSchema]) -> JsonSchema
fn Builder::array(Self, items? : JsonSchema, prefixItems? : Array[JsonSchema], contains? : JsonSchema, minContains? : Int, maxContains? : Int, minItems? : Int, maxItems? : Int, uniqueItems? : Bool, description? : String) -> JsonSchema
fn Builder::boolean(Self, description? : String) -> JsonSchema
fn Builder::const_(Self, Json) -> JsonSchema
fn Builder::enum_(Self, Array[Json]) -> JsonSchema
fn Builder::enumerable_one_of(Self, String, Array[JsonSchema], params~ : JsonSchema?) -> JsonSchema
fn Builder::integer(Self, description? : String, minimum? : Int, maximum? : Int, exclusiveMinimum? : Int, exclusiveMaximum? : Int, multipleOf? : Int) -> JsonSchema
fn Builder::new() -> Self
fn Builder::null(Self, description? : String) -> JsonSchema
fn Builder::number(Self, description? : String, minimum? : Double, maximum? : Double, exclusiveMinimum? : Double, exclusiveMaximum? : Double, multipleOf? : Double) -> JsonSchema
fn Builder::object(Self, description? : String, properties? : Map[String, JsonSchema], required? : Array[String], additionalProperties? : JsonSchema, patternProperties? : Map[String, JsonSchema], propertyNames? : JsonSchema, dependentSchemas? : Map[String, JsonSchema], dependentRequired? : Map[String, Array[String]], minProperties? : Int, maxProperties? : Int, required_all? : Bool) -> JsonSchema
fn Builder::one_of(Self, Array[JsonSchema]) -> JsonSchema
fn Builder::ref_(Self, JsonPointer) -> JsonSchema
fn Builder::ref_from_string(Self, String) -> JsonSchema
fn Builder::string(Self, minLength? : Int, maxLength? : Int, pattern? : String, format? : String, enum_? : Array[String], contentEncoding? : String, contentMediaType? : String, description? : String) -> JsonSchema

pub(all) struct Enumerable {
  tag : String
  positionals : Array[JsonSchema]?
  params : Map[String, JsonSchema]?
}
fn Enumerable::new(String, Array[JsonSchema]?, Map[String, JsonSchema]?) -> Self
fn Enumerable::parse_enumerable(JsonSchema) -> Array[Self]?
impl Eq for Enumerable
impl Show for Enumerable

pub(all) enum JsonPointer {
  Root
  Key(JsonPointer, key~ : String)
  Index(JsonPointer, index~ : Int)
}
fn JsonPointer::access(Self, Json) -> Json?
fn JsonPointer::from_string(String) -> Result[Self, String]
fn JsonPointer::index(Self, Int) -> Self
fn JsonPointer::key(Self, String) -> Self
impl Eq for JsonPointer
impl Hash for JsonPointer
impl Show for JsonPointer
impl ToJson for JsonPointer
impl @json.FromJson for JsonPointer

pub enum JsonSchema {
  Any(description~ : String?)
  Null(description~ : String?)
  Boolean(description~ : String?)
  String(minLength~ : Int?, maxLength~ : Int?, pattern~ : String?, format~ : String?, enum_~ : Array[String]?, contentEncoding~ : String?, contentMediaType~ : String?, description~ : String?)
  Number(minimum~ : Double?, maximum~ : Double?, exclusiveMinimum~ : Double?, exclusiveMaximum~ : Double?, multipleOf~ : Double?, description~ : String?)
  Integer(minimum~ : Int?, maximum~ : Int?, exclusiveMinimum~ : Int?, exclusiveMaximum~ : Int?, multipleOf~ : Int?, description~ : String?)
  Array(items~ : JsonSchema?, prefixItems~ : Array[JsonSchema]?, contains~ : JsonSchema?, minContains~ : Int?, maxContains~ : Int?, minItems~ : Int?, maxItems~ : Int?, uniqueItems~ : Bool?, description~ : String?)
  Object(properties~ : Map[String, JsonSchema]?, required~ : Array[String]?, additionalProperties~ : JsonSchema?, patternProperties~ : Map[String, JsonSchema]?, propertyNames~ : JsonSchema?, dependentSchemas~ : Map[String, JsonSchema]?, dependentRequired~ : Map[String, Array[String]]?, minProperties~ : Int?, maxProperties~ : Int?, description~ : String?)
  Enum(Array[Json])
  Const(Json)
  AnyOf(Array[JsonSchema])
  AllOf(Array[JsonSchema])
  OneOf(Array[JsonSchema])
  Not(JsonSchema)
  Ref(JsonPointer)
}
fn JsonSchema::validate(Self, Json) -> Result[Unit, Array[ValidationError]] raise
impl Eq for JsonSchema
impl Show for JsonSchema
impl ToJson for JsonSchema
impl @json.FromJson for JsonSchema

pub(all) struct Resolver {
  // private fields
}
fn Resolver::get_refs(Self) -> Array[JsonPointer]
fn Resolver::has(Self, JsonPointer) -> Bool
fn Resolver::new(Json) -> Self raise ParseError
fn Resolver::resolve(Self, JsonPointer) -> JsonSchema?

pub struct ValidationError {
  input : Json
  json_path : JsonPointer
  schema_path : JsonPointer
  message : String
  children : Array[ValidationError]?
}
fn ValidationError::new(Json, JsonPointer, JsonPointer, String, children? : Array[Self]) -> Self
impl Eq for ValidationError
impl Show for ValidationError

type Validator
fn Validator::validate(Self, Json) -> Result[Unit, Array[ValidationError]] raise RuntimeError
fn Validator::with_resolver(JsonSchema, Resolver) -> Self

// Type aliases

// Traits

