///|
pub fn generate(
  raw_json : Json,
  entrypoints : Array[JsonPointer],
  root_name? : String = "Root",
  include_refs? : Bool = true,
  prefix? : String = "",
) -> Result[String, String] raise {
  let logger = StringBuilder::new()
  let entries : Set[JsonPointer] = Set::from_array(entrypoints)
  if include_refs {
    for ref_expr in @jsonschema.collect_refs(raw_json) {
      guard JsonPointer::from_string(ref_expr) is Ok(pointer) else { continue }
      entries.add(pointer)
    }
  }
  for ref_expr in @jsonschema.collect_refs(raw_json) {
    guard JsonPointer::from_string(ref_expr) is Ok(pointer) else { continue }
    entries.add(pointer)
  }
  logger.write_string("// Generated by jsonschema\n")
  for entrypoint in entries {
    guard entrypoint.access(raw_json) is Some(json) else { continue }
    let struct_name = match entrypoint {
      @jsonschema.JsonPointer::Root => root_name
      @jsonschema.JsonPointer::Key(_, key~) => key
      _ => continue
    }
    let resolver = @jsonschema.build_resolver(raw_json)
    try {
      let schema : JsonSchema = @json.from_json(json)
      logger.write_string("\n// \{entrypoint}\n")
      if generate_stmt(
          schema,
          struct_name,
          resolver~,
          pointer=entrypoint,
          prefix~,
        )
        is Ok(code) {
        logger.write_string(code)
      } else {
        logger.write_string("\n// skip by compile error \{entrypoint}\n")
      }
    } catch {
      err => return Err("failed to parse schema at \{entrypoint}: \{err}")
    }
  }
  logger.to_string() |> Ok
}

///|
fn generate_stmt(
  schema : JsonSchema,
  struct_name : String,
  resolver~ : @jsonschema.Resolver,
  prefix? : String = "",
  pointer? : JsonPointer = JsonPointer::Root.key(struct_name),
) -> Result[String, String] {
  match schema {
    OneOf(_) => {
      guard Enumerable::parse_enumerable(schema) is Some(enumerable) else {
        return Err("OneOf without prefixItems is not supported")
      }
      render_enumerable(struct_name, enumerable, prefix~, resolver~, pointer~)
      |> Ok
    }
    Object(properties=None, ..) =>
      // empty object
      "\{prefix}struct \{struct_name} {} derive(Show, Eq, FromJson, ToJson)"
      |> Ok
    Object(properties=Some(properties), required~, ..) => {
      let inner = StringBuilder::new()
      inner.write_string("\{prefix}struct \{struct_name} {\n")
      let required_keys = if required is Some(v) {
        v |> Set::from_array
      } else {
        Set::new()
      }
      let outer = StringBuilder::new()
      for key, subschema in properties {
        // nested object
        if subschema is JsonSchema::Object(..) {
          let sub_pointer = pointer.key(key)
          let sub_struct_name = "\{struct_name}_\{key}"
          inner.write_string("  \{key}: \{sub_struct_name}\n")
          match
            generate_stmt(
              subschema,
              sub_struct_name,
              resolver~,
              pointer=sub_pointer,
            ) {
            Err(e) => return Err(e)
            Ok(nested_code) => outer.write_string(nested_code)
          }
        } else {
          // child property
          let key_is_required = required_keys.contains(key)
          let subtype_code = generate_type_expr(
            subschema,
            resolver~,
            pointer=pointer.key(key),
          )
          if !key_is_required && !subtype_code.has_suffix("?") {
            inner.write_string("  \{key}: \{subtype_code}?\n")
          } else {
            inner.write_string("  \{key}: \{subtype_code}\n")
          }
        }
      }
      inner
      ..write_string("} derive(Eq, Show, FromJson, ToJson)\n")
      ..write_string(outer.to_string())
      inner.to_string() |> Ok
    }
    Integer(..) | Number(..) | String(..) | Boolean(..) | Ref(_) => {
      let code = generate_type_expr(schema, resolver~, pointer~)
      "\{prefix}struct \{struct_name}(\{code}) derive(Eq, Show, FromJson, ToJson)"
      |> Ok
    }
    e => "\"Not Supported\" \{e}" |> Err
  }
}

///|
fn generate_type_expr(
  schema : JsonSchema,
  resolver~ : @jsonschema.Resolver,
  pointer? : JsonPointer = JsonPointer::Root,
) -> String {
  match schema {
    Object(..) => return "Error: direct nested schema not supported"
    Array(items~, ..) => {
      let logger = StringBuilder::new()
      logger.write_string("Array[")
      if items is Some(value) {
        logger.write_string(
          generate_type_expr(value, resolver~, pointer=pointer.key("index")),
        )
      } else {
        logger.write_string("Any")
      }
      logger.write_string("]")
      return logger.to_string()
    }
    String(..) => "String"
    Number(..) => "Double"
    Integer(..) => "Int"
    Boolean(..) => "Bool"
    OneOf(_) =>
      if parse_nullable(schema) is Some(other) {
        generate_type_expr(other, resolver~, pointer~) + "?"
      } else {
        "Json?"
      }
    JsonSchema::Const(_) | JsonSchema::Enum(_) => "Json"
    JsonSchema::Ref(pointer) =>
      ref_to_identifier(pointer).unwrap_or("UnresolvedRef")
    _ => "\"unsupported type\""
  }
}

///|
fn parse_nullable(schema : JsonSchema) -> JsonSchema? {
  match schema {
    OneOf(schemas) if schemas.length() == 2 =>
      match schemas {
        [JsonSchema::Null(_), other] | [other, JsonSchema::Null(_)] =>
          Some(other)
        _ => None
      }
    _ => None
  }
}

///|
fn ref_to_identifier(pointer : JsonPointer) -> String? {
  match pointer {
    JsonPointer::Root => Some("Root")
    JsonPointer::Key(_, key~) => Some(key)
    JsonPointer::Index(_, index~) => Some(index.to_string())
  }
}

///|
test "mbt code generation" {
  let schema : Json = @json.parse(
    (
      #|{
      #|  "type": "object",
      #|  "properties": {
      #|    "name": { "type": "string" },
      #|    "age": { "type": "number" },
      #|    "items": {
      #|      "type": "array",
      #|      "items": { "type": "string" }
      #|    },
      #|    "opt_str": {
      #|      "oneOf": [
      #|        { "type": "string" },
      #|        { "type": "null" }
      #|      ]
      #|    },
      #|    "opt_number": {
      #|      "oneOf": [
      #|        { "type": "number" },
      #|        { "type": "null" }
      #|      ]
      #|    }
      #|  },
      #|  "required": ["name", "age"]
      #|}
    ),
  )
  let jschema : JsonSchema = @json.from_json(schema)
  let resolver = @jsonschema.build_resolver(schema)
  let code = generate_stmt(jschema, "MyStruct", resolver~)
  inspect(
    code.unwrap(),
    content=(
      #|struct MyStruct {
      #|  name: String
      #|  age: Double
      #|  items: Array[String]?
      #|  opt_str: String?
      #|  opt_number: Double?
      #|} derive(Eq, Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "mbt code generation with inner struct" (t : @test.T) {
  let schema : Json = @json.parse(
    (
      #|{
      #|  "type": "object",
      #|  "properties": {
      #|    "nested": {
      #|      "type": "object",
      #|      "required": ["id"], 
      #|      "properties": {
      #|        "id": { "type": "integer" }
      #|      }
      #|    },
      #|    "d1": {
      #|      "type": "object",
      #|      "required": ["d2"], 
      #|      "properties": {
      #|        "d2": {
      #|          "type": "object",
      #|          "required": ["d3"], 
      #|          "properties": {
      #|            "d3": { "type": "string" }
      #|          }
      #|        }
      #|      }
      #|    }
      #|  },
      #|  "required": ["nested"]
      #|}
    ),
  )
  let jschema : JsonSchema = @json.from_json(schema)
  let resolver = @jsonschema.build_resolver(schema)
  let code = generate_stmt(jschema, "MyStruct", resolver~)
  t..write(code.unwrap())..snapshot(filename="nested_struct.mbt")
}

///|
test "mbt struct generation with ref" {
  let schema : Json = {
    "definitions": {
      "Point": {
        "type": "object",
        "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
        "required": ["x", "y"],
      },
    },
    "type": "object",
    "properties": {
      "points": { "type": "array", "items": { "$ref": "#/definitions/Point" } },
    },
    "required": ["points"],
  }
  let jschema : JsonSchema = @json.from_json(schema)
  let resolver = @jsonschema.build_resolver({
    "definitions": {
      "Point": {
        "type": "object",
        "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
        "required": ["x", "y"],
      },
    },
  })
  let code = generate_stmt(jschema, "MyStruct", resolver~)
  inspect(
    code.unwrap(),
    content=(
      #|struct MyStruct {
      #|  points: Array[Point]
      #|} derive(Eq, Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "generate_mbt_code" {
  let schema : Json = {
    "definitions": {
      "Point": {
        "type": "object",
        "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
        "required": ["x", "y"],
      },
      "Point3D": {
        "type": "object",
        "properties": {
          "x": { "type": "number" },
          "y": { "type": "number" },
          "z": { "type": "number" },
        },
        "required": ["x", "y", "z"],
      },
    },
    "type": "object",
    "properties": {
      "points": { "type": "array", "items": { "$ref": "#/definitions/Point" } },
    },
    "required": ["points"],
  }
  let code = generate(
    schema,
    [JsonPointer::Root.key("definitions").key("Point3D"), JsonPointer::Root],
    root_name="MyApp",
    include_refs=true,
  )
  inspect(
    code.unwrap(),
    content=(
      #|// Generated by jsonschema
      #|
      #|// #/definitions/Point3D
      #|struct Point3D {
      #|  x: Double
      #|  y: Double
      #|  z: Double
      #|} derive(Eq, Show, FromJson, ToJson)
      #|
      #|// #
      #|struct MyApp {
      #|  points: Array[Point]
      #|} derive(Eq, Show, FromJson, ToJson)
      #|
      #|// #/definitions/Point
      #|struct Point {
      #|  x: Double
      #|  y: Double
      #|} derive(Eq, Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "render nested enumberable" (t : @test.T) {
  let raw : Json = {
    "definitions": {
      "V": {
        "oneOf": [
          {
            "type": "array",
            "prefixItems": [{ "const": "V1" }, { "type": "number" }],
          },
          {
            "type": "array",
            "prefixItems": [{ "const": "V2" }, { "type": "integer" }],
          },
        ],
      },
      "A": {
        "type": "object",
        "required": ["a"],
        "properties": { "a": { "$ref": "#/definitions/V" } },
      },
      "B": {
        "type": "object",
        "required": ["b"],
        "properties": { "b": { "$ref": "#/definitions/A" } },
      },
    },
  }
  let code = generate(
    raw,
    [JsonPointer::Root.key("definitions").key("B")],
    root_name="Root",
  )
  let output = code.unwrap().to_string()
  t.write(output)
  t.snapshot(filename="generated_enum.mbt")
}

///|
test "stmt" (t : @test.T) {
  let raw : Json = {
    "definitions": {
      "Obj": {
        "type": "object",
        "properties": { "x": { "type": "integer" }, "y": { "type": "integer" } },
        "required": ["x", "y"],
      },
    },
    "$ref": "#/definitions/Obj",
  }
  let generated = generate(
    raw,
    [JsonPointer::Root.key("definitions").key("Obj"), JsonPointer::Root],
    root_name="Root",
  )
  let generated = generated.unwrap_or("failed")
  t.write(generated)
  t.snapshot(filename="generated_ref.mbt")
}

///|
test "generate ref entry" {
  let b = @jsonschema.Builder::new()
  let dummy_resolver = @jsonschema.build_resolver({
    "definitions": { "Num": { "type": "integer" } },
  })
  let refstr = JsonPointer::Root.key("definitions").key("Num")
  ref_to_identifier(refstr) |> assert_eq(Some("Num"))
  // let expr = JsonSchema::ref_from_string("#/definitions/Num")
  let expr = b.ref_(JsonPointer::Root.key("definitions").key("Num"))
  generate_type_expr(expr, resolver=dummy_resolver) |> assert_eq("Num")
  generate_type_expr(
    b.array(items=b.ref_from_string("#/definitions/Num")),
    resolver=dummy_resolver,
  )
  |> assert_eq("Array[Num]")
  generate_type_expr(b.string(), resolver=dummy_resolver) |> assert_eq("String")
  generate_type_expr(b.integer(), resolver=dummy_resolver) |> assert_eq("Int")
  generate_type_expr(b.const_("something_json"), resolver=dummy_resolver)
  |> assert_eq("Json")
  generate_type_expr(b.enum_([{ "a": 1 }, { "b": 2 }]), resolver=dummy_resolver)
  |> assert_eq("Json")
}

///|
fn[T, E] assert_ok(x : Result[T, E]) -> Unit {
  guard x is Ok(_)
}

///|
fn[T, E] assert_err(x : Result[T, E]) -> Unit {
  guard x is Err(_)
}

///|
test "enumerable schema can parse itself" (_t : @test.T) {
  let b = @jsonschema.Builder::new()
  let s = b.one_of([
    b.array(prefixItems=[b.const_("A"), b.integer(), b.string()]),
    b.array(prefixItems=[b.const_("B"), b.number()]),
    b.array(prefixItems=[b.const_("C"), b.integer()]),
    b.const_("D"),
    b.array(prefixItems=[
      b.const_("Paramed"),
      b.object(properties={ "a": b.integer() }, required=["a"]),
    ]),
  ])
  let s = s.to_json().stringify()
  let reparsed : Json = @json.parse(s)
  let reschema : JsonSchema = @json.from_json(reparsed)
  reschema.validate("Not match") |> assert_err
  reschema.validate(["A", 1, "str"]) |> assert_ok
  reschema.validate(["B", 3.14]) |> assert_ok
  reschema.validate(["B", "err"]) |> assert_err
  reschema.validate(["C", 42]) |> assert_ok
  reschema.validate("D") |> assert_ok
  reschema.validate("NotExist") |> assert_err
  reschema.validate(["Paramed", { "a": 10 }]) |> assert_ok
  reschema.validate(["Paramed", { "a": "not a number" }]) |> assert_err
}
