///|
pub fn generate(
  raw_json : Json,
  entrypoints : Array[JsonPointer],
  root_name? : String = "Root",
  include_refs? : Bool = true,
  // derives? : Array[String] = ["Show", "FromJson", "ToJson"],
  prefix? : String = "",
) -> Result[String, String] raise {
  let logger = StringBuilder::new()
  let entries : Set[JsonPointer] = Set::from_array(entrypoints)
  if include_refs {
    for ref_expr in @jsonschema.collect_refs(raw_json) {
      guard JsonPointer::from_string(ref_expr) is Ok(pointer) else { continue }
      entries.add(pointer)
    }
  }
  for ref_expr in @jsonschema.collect_refs(raw_json) {
    guard JsonPointer::from_string(ref_expr) is Ok(pointer) else { continue }
    entries.add(pointer)
  }
  logger.write_string("// Generated by jsonschema\n")
  for entrypoint in entries {
    guard entrypoint.access(raw_json) is Some(json) else { continue }
    let struct_name = match entrypoint {
      @jsonschema.JsonPointer::Root => root_name
      @jsonschema.JsonPointer::Key(_, key~) => key
      _ => continue
    }
    let resolver = @jsonschema.build_resolver(raw_json)
    try {
      let schema : JsonSchema = @json.from_json(json)
      logger.write_string("\n// \{entrypoint}\n")
      if generate_stmt(
          schema,
          struct_name,
          resolver~,
          pointer=entrypoint,
          prefix~,
        )
        is Ok(code) {
        logger.write_string(code)
      } else {
        logger.write_string("\n// skip by compile error \{entrypoint}\n")
      }
    } catch {
      err => return Err("failed to parse schema at \{entrypoint}: \{err}")
    }
  }
  logger.to_string() |> Ok
}

///|
fn generate_stmt(
  schema : JsonSchema,
  struct_name : String,
  resolver~ : @jsonschema.Resolver,
  prefix? : String = "",
  pointer? : JsonPointer = JsonPointer::Root.key(struct_name),
) -> Result[String, String] {
  match schema {
    JsonSchema::OneOf(_) => {
      guard EnumerableOneOf::parse_enumerable_one_of(schema)
        is Some(enum_values) else {
        return Err("OneOf without prefixItems is not supported")
      }
      render_enumerable_one_of(
        struct_name,
        enum_values,
        prefix~,
        resolver~,
        pointer~,
      )
      |> Ok
    }
    JsonSchema::Object(properties=None, ..) =>
      // empty object
      "\{prefix}struct \{struct_name} {} derive(Show, Eq, FromJson, ToJson)"
      |> Ok
    JsonSchema::Object(properties=Some(properties), required~, ..) => {
      let inner = StringBuilder::new()
      inner.write_string("\{prefix}struct \{struct_name} {\n")
      let required_keys = if required is Some(v) {
        v |> Set::from_array
      } else {
        Set::new()
      }
      let outer = StringBuilder::new()
      for key, subschema in properties {
        // nested object
        if subschema is JsonSchema::Object(..) {
          let sub_pointer = pointer.key(key)
          let sub_struct_name = sub_pointer.to_symbol_name()
          inner.write_string("  \{key}: \{sub_struct_name}\n")
          match
            generate_stmt(
              subschema,
              sub_struct_name,
              resolver~,
              pointer=sub_pointer,
            ) {
            Err(e) => return Err(e)
            Ok(nested_code) => outer.write_string(nested_code)
          }
        } else {
          // child property
          let key_is_required = required_keys.contains(key)
          let subtype_code = generate_type_expr(
            subschema,
            resolver~,
            pointer=pointer.key(key),
          )
          if !key_is_required && !subtype_code.has_suffix("?") {
            inner.write_string("  \{key}: \{subtype_code}?\n")
          } else {
            inner.write_string("  \{key}: \{subtype_code}\n")
          }
        }
      }
      inner
      ..write_string("} derive(Show, FromJson, ToJson)\n")
      ..write_string(outer.to_string())
      inner.to_string() |> Ok
    }
    JsonSchema::Integer(..)
    | JsonSchema::Number(..)
    | JsonSchema::String(..)
    | JsonSchema::Boolean(..)
    | JsonSchema::Ref(_) => {
      let code = generate_type_expr(schema, resolver~, pointer~)
      "\{prefix}struct \{struct_name}(\{code}) derive(Show, Eq, FromJson, ToJson)"
      |> Ok
    }
    e => "\"Not Supported\" \{e}" |> Err
  }
}

///|
fn generate_type_expr(
  schema : JsonSchema,
  resolver~ : @jsonschema.Resolver,
  pointer? : JsonPointer = JsonPointer::Root,
) -> String {
  match schema {
    JsonSchema::Object(..) => return "Error: direct nested schema not supported"
    JsonSchema::Array(items~, ..) => {
      let logger = StringBuilder::new()
      logger.write_string("Array[")
      if items is Some(value) {
        logger.write_string(
          generate_type_expr(value, resolver~, pointer=pointer.key("index")),
        )
      } else {
        logger.write_string("Any")
      }
      logger.write_string("]")
      return logger.to_string()
    }
    JsonSchema::String(..) => "String"
    JsonSchema::Number(..) => "Double"
    JsonSchema::Integer(..) => "Int"
    JsonSchema::Boolean(..) => "Bool"
    JsonSchema::OneOf(schemas) =>
      if schemas.length() == 2 {
        match schemas {
          [JsonSchema::Null(_), other] | [other, JsonSchema::Null(_)] =>
            return generate_type_expr(other, resolver~, pointer~) + "?"
          _ => "Json?"
        }
      } else {
        "Json?"
      }
    JsonSchema::Const(_) | JsonSchema::Enum(_) => "Json"
    JsonSchema::Ref(pointer) =>
      ref_to_identifier(pointer).unwrap_or("UnresolvedRef")
    _ => "\"unsupported type\""
  }
}

///|
fn ref_to_identifier(pointer : JsonPointer) -> String? {
  match pointer {
    JsonPointer::Root => Some("Root")
    JsonPointer::Key(_, key~) => Some(key)
    JsonPointer::Index(_, index~) => Some(index.to_string())
  }
  // match pointer.split("/").to_array() {
  //   [.., last] => Some(last.to_string())
  //   _ => None
  // }
}

///|
/// Convert to safe string for struct/variable names
fn to_symbol_name(self : JsonPointer) -> String {
  let logger : StringBuilder = StringBuilder::new()
  self.to_symbol_name_inner(logger)
  logger.to_string()
}

///|
fn to_symbol_name_inner(self : JsonPointer, logger : StringBuilder) -> Unit {
  match self {
    Root => logger.write_string("")
    Key(p, key~) =>
      logger
      ..write_string(p.to_symbol_name())
      ..write_string("_")
      ..write_string(key)
    Index(p, index~) =>
      logger
      ..write_string(p.to_symbol_name())
      ..write_string("_")
      ..write_string(index.to_string())
  }
}

///|
test "mbt code generation" {
  let schema : Json = @json.parse(
    (
      #|{
      #|  "type": "object",
      #|  "properties": {
      #|    "name": { "type": "string" },
      #|    "age": { "type": "number" },
      #|    "items": {
      #|      "type": "array",
      #|      "items": { "type": "string" }
      #|    },
      #|    "opt_str": {
      #|      "oneOf": [
      #|        { "type": "string" },
      #|        { "type": "null" }
      #|      ]
      #|    },
      #|    "opt_number": {
      #|      "oneOf": [
      #|        { "type": "number" },
      #|        { "type": "null" }
      #|      ]
      #|    }
      #|  },
      #|  "required": ["name", "age"]
      #|}
    ),
  )
  let jschema : JsonSchema = @json.from_json(schema)
  let resolver = @jsonschema.build_resolver(schema)
  let code = generate_stmt(jschema, "MyStruct", resolver~)
  inspect(
    code.unwrap(),
    content=(
      #|struct MyStruct {
      #|  name: String
      #|  age: Double
      #|  items: Array[String]?
      #|  opt_str: String?
      #|  opt_number: Double?
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "mbt code generation with inner struct" {
  let schema : Json = @json.parse(
    (
      #|{
      #|  "type": "object",
      #|  "properties": {
      #|    "nested": {
      #|      "type": "object",
      #|      "required": ["id"], 
      #|      "properties": {
      #|        "id": { "type": "integer" }
      #|      }
      #|    },
      #|    "d1": {
      #|      "type": "object",
      #|      "required": ["d2"], 
      #|      "properties": {
      #|        "d2": {
      #|          "type": "object",
      #|          "required": ["d3"], 
      #|          "properties": {
      #|            "d3": { "type": "string" }
      #|          }
      #|        }
      #|      }
      #|    }
      #|  },
      #|  "required": ["nested"]
      #|}
    ),
  )
  let jschema : JsonSchema = @json.from_json(schema)
  let resolver = @jsonschema.build_resolver(schema)
  let code = generate_stmt(jschema, "MyStruct", resolver~)
  inspect(
    code.unwrap(),
    content=(
      #|struct MyStruct {
      #|  nested: _MyStruct_nested
      #|  d1: _MyStruct_d1
      #|} derive(Show, FromJson, ToJson)
      #|struct _MyStruct_nested {
      #|  id: Int
      #|} derive(Show, FromJson, ToJson)
      #|struct _MyStruct_d1 {
      #|  d2: _MyStruct_d1_d2
      #|} derive(Show, FromJson, ToJson)
      #|struct _MyStruct_d1_d2 {
      #|  d3: String
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "mbt struct generation with ref" {
  let schema : Json = {
    "definitions": {
      "Point": {
        "type": "object",
        "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
        "required": ["x", "y"],
      },
    },
    "type": "object",
    "properties": {
      "points": { "type": "array", "items": { "$ref": "#/definitions/Point" } },
    },
    "required": ["points"],
  }
  let jschema : JsonSchema = @json.from_json(schema)
  let resolver = @jsonschema.build_resolver({
    "definitions": {
      "Point": {
        "type": "object",
        "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
        "required": ["x", "y"],
      },
    },
  })
  let code = generate_stmt(jschema, "MyStruct", resolver~)
  inspect(
    code.unwrap(),
    content=(
      #|struct MyStruct {
      #|  points: Array[Point]
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "generate_mbt_code" {
  let schema : Json = {
    "definitions": {
      "Point": {
        "type": "object",
        "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
        "required": ["x", "y"],
      },
      "Point3D": {
        "type": "object",
        "properties": {
          "x": { "type": "number" },
          "y": { "type": "number" },
          "z": { "type": "number" },
        },
        "required": ["x", "y", "z"],
      },
    },
    "type": "object",
    "properties": {
      "points": { "type": "array", "items": { "$ref": "#/definitions/Point" } },
    },
    "required": ["points"],
  }
  let code = generate(
    schema,
    [JsonPointer::Root.key("definitions").key("Point3D"), JsonPointer::Root],
    root_name="MyApp",
    include_refs=true,
  )
  inspect(
    code.unwrap(),
    content=(
      #|// Generated by jsonschema
      #|
      #|// #/definitions/Point3D
      #|struct Point3D {
      #|  x: Double
      #|  y: Double
      #|  z: Double
      #|} derive(Show, FromJson, ToJson)
      #|
      #|// #
      #|struct MyApp {
      #|  points: Array[Point]
      #|} derive(Show, FromJson, ToJson)
      #|
      #|// #/definitions/Point
      #|struct Point {
      #|  x: Double
      #|  y: Double
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "render nested enumberable" {
  let raw : Json = {
    "definitions": {
      "V": {
        "oneOf": [
          {
            "type": "array",
            "prefixItems": [{ "const": "V1" }, { "type": "number" }],
          },
          {
            "type": "array",
            "prefixItems": [{ "const": "V2" }, { "type": "integer" }],
          },
        ],
      },
      "A": {
        "type": "object",
        "required": ["a"],
        "properties": { "a": { "$ref": "#/definitions/V" } },
      },
      "B": {
        "type": "object",
        "required": ["b"],
        "properties": { "b": { "$ref": "#/definitions/A" } },
      },
    },
  }
  let code = generate(
    raw,
    [JsonPointer::Root.key("definitions").key("B")],
    root_name="Root",
  )
  inspect(
    code.unwrap(),
    content=(
      #|// Generated by jsonschema
      #|
      #|// #/definitions/B
      #|struct B {
      #|  b: A
      #|} derive(Show, FromJson, ToJson)
      #|
      #|// #/definitions/V
      #|enum V {
      #|  V1(Double)
      #|  V2(Int)
      #|} derive(Show, Eq, FromJson, ToJson)
      #|
      #|// #/definitions/A
      #|struct A {
      #|  a: V
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "stmt" {
  let b = @jsonschema.Builder::new()
  // let dummy_resolver = fn(_) { Some(JsonSchema::integer()) }
  let resolver = @jsonschema.build_resolver({
    "definitions": { "Num": { "type": "integer" } },
  })
  match
    generate_stmt(
      b.ref_(JsonPointer::Root.key("definitions").key("Num")),
      "Root",
      resolver~,
    ) {
    Err(e) => fail("unreachable: \{e}")
    Ok(code) =>
      inspect(
        code,
        content="struct Root(Num) derive(Show, Eq, FromJson, ToJson)",
      )
  }
  let resolver2 = @jsonschema.build_resolver({
    "definitions": {
      "Obj": {
        "type": "object",
        "properties": { "x": { "type": "integer" }, "y": { "type": "integer" } },
        "required": ["x", "y"],
      },
    },
  })
  match
    generate_stmt(
      b.ref_from_string("#/definitions/Obj"),
      "Root",
      resolver=resolver2,
    ) {
    Err(e) => fail("unreachable: \{e}")
    Ok(code) =>
      inspect(
        code,
        content=(
          #|struct Root(Obj) derive(Show, Eq, FromJson, ToJson)
        ),
      )
  }
}

///|
test "ref to type expr" {
  let b = @jsonschema.Builder::new()
  let dummy_resolver = @jsonschema.build_resolver({
    "definitions": { "Num": { "type": "integer" } },
  })
  let refstr = JsonPointer::Root.key("definitions").key("Num")
  ref_to_identifier(refstr) |> assert_eq(Some("Num"))
  // let expr = JsonSchema::ref_from_string("#/definitions/Num")
  let expr = b.ref_(JsonPointer::Root.key("definitions").key("Num"))
  generate_type_expr(expr, resolver=dummy_resolver) |> assert_eq("Num")
  generate_type_expr(
    b.array(items=b.ref_from_string("#/definitions/Num")),
    resolver=dummy_resolver,
  )
  |> assert_eq("Array[Num]")
  generate_type_expr(b.string(), resolver=dummy_resolver) |> assert_eq("String")
  generate_type_expr(b.integer(), resolver=dummy_resolver) |> assert_eq("Int")
  generate_type_expr(b.const_("something_json"), resolver=dummy_resolver)
  |> assert_eq("Json")
  generate_type_expr(b.enum_([{ "a": 1 }, { "b": 2 }]), resolver=dummy_resolver)
  |> assert_eq("Json")
}
