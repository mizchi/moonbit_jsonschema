///|
pub fn generate_moonbit(
  raw_json : Json,
  entrypoints : Array[JsonPointer],
  root_name? : String = "Root",
  include_refs? : Bool = true,
  // derives? : Array[String] = ["Show", "FromJson", "ToJson"],
  prefix? : String = "",
) -> Result[String, String] {
  let logger = StringBuilder::new()
  let entries : Set[JsonPointer] = Set::from_array(entrypoints)
  if include_refs {
    for ref_expr in @jsonschema.collect_refs(raw_json) {
      guard JsonPointer::from_string(ref_expr) is Ok(pointer) else { continue }
      entries.add(pointer)
    }
  }
  for ref_expr in @jsonschema.collect_refs(raw_json) {
    guard JsonPointer::from_string(ref_expr) is Ok(pointer) else { continue }
    entries.add(pointer)
  }
  logger.write_string("// Generated by jsonschema\n")
  for entry_path in entries {
    guard entry_path.access(raw_json) is Some(json) else { continue }
    let struct_name = match entry_path {
      @jsonschema.JsonPointer::Root => root_name
      @jsonschema.JsonPointer::Key(_, key~) => key
      _ => continue
    }
    let resolver = @jsonschema.build_resolver(raw_json)
    try {
      let schema : JsonSchema = @json.from_json(json)
      logger.write_string("\n// \{entry_path}\n")
      if generate_moonbit_statement(
          schema,
          struct_name,
          resolver~,
          pointer=entry_path,
          prefix~,
        )
        is Ok(code) {
        logger.write_string(code)
      } else {
        logger.write_string("\n// skip by compile error \{entry_path}\n")
      }
    } catch {
      err => return Err("failed to parse schema at \{entry_path}: \{err}")
    }
  }
  logger.to_string() |> Ok
}

///|
fn generate_moonbit_statement(
  schema : JsonSchema,
  struct_name : String,
  resolver~ : (String) -> JsonSchema?,
  prefix? : String = "",
  pointer? : JsonPointer = JsonPointer::Root.key(struct_name),
) -> Result[String, String] {
  match schema {
    // Root is $ref
    JsonSchema::Ref(ref_pointer) =>
      match resolver(ref_pointer) {
        Some(resolved_schema) =>
          generate_moonbit_statement(
            resolved_schema,
            struct_name,
            resolver~,
            prefix~,
            pointer~,
          )
        None => Err("ref schema not found")
      }
    JsonSchema::OneOf(_) => {
      guard parse_enumerable_one_of(schema) is Some(enum_values) else {
        return Err("OneOf without prefixItems is not supported")
      }
      render_enum(struct_name, enum_values, prefix~, resolver~, pointer~) |> Ok
    }
    JsonSchema::Object(properties=None, ..) =>
      return Err("properties is required")
    JsonSchema::Object(properties=Some(properties), required~, ..) => {
      let inner = StringBuilder::new()
      inner.write_string("\{prefix}struct \{struct_name} {\n")
      let required_keys = if required is Some(v) {
        v |> Set::from_array
      } else {
        Set::new()
      }
      let outer = StringBuilder::new()
      for key, subschema in properties {
        // nested object
        if subschema is JsonSchema::Object(..) {
          let sub_pointer = pointer.key(key)
          let sub_struct_name = sub_pointer.to_symbol_name()
          inner.write_string("  \{key}: \{sub_struct_name}\n")
          match
            generate_moonbit_statement(
              subschema,
              sub_struct_name,
              resolver~,
              pointer=sub_pointer,
            ) {
            Err(e) => return Err(e)
            Ok(nested_code) => outer.write_string(nested_code)
          }
        } else {
          // child property
          let key_is_required = required_keys.contains(key)
          let subtype_code = generate_moonbit_property(
            subschema,
            resolver~,
            pointer=pointer.key(key),
          )
          if !key_is_required && !subtype_code.has_suffix("?") {
            inner.write_string("  \{key}: \{subtype_code}?\n")
          } else {
            inner.write_string("  \{key}: \{subtype_code}\n")
          }
        }
      }
      inner.write_string("} derive(Show, FromJson, ToJson)\n")
      inner.write_string(outer.to_string())
      inner.to_string() |> Ok
    }
    _ => "\"Not Supported\"" |> Err
  }
}

///|
fn generate_moonbit_property(
  schema : JsonSchema,
  resolver~ : (String) -> JsonSchema?,
  pointer? : JsonPointer = JsonPointer::Root,
) -> String {
  match schema {
    JsonSchema::Object(..) => return "Error: direct nested schema not supported"
    JsonSchema::Array(items~, ..) => {
      let logger = StringBuilder::new()
      logger.write_string("Array[")
      if items is Some(value) {
        logger.write_string(
          generate_moonbit_property(
            value,
            resolver~,
            pointer=pointer.key("index"),
          ),
        )
      } else {
        logger.write_string("Any")
      }
      logger.write_string("]")
      return logger.to_string()
    }
    JsonSchema::String(..) => "String"
    JsonSchema::Number(..) => "Double"
    JsonSchema::Integer(..) => "Int"
    JsonSchema::Boolean(..) => "Bool"
    JsonSchema::OneOf(schemas) =>
      if schemas.length() == 2 {
        match schemas {
          [JsonSchema::Null(_), other] | [other, JsonSchema::Null(_)] =>
            return generate_moonbit_property(other, resolver~, pointer~) + "?"
          _ => "Json?"
        }
      } else {
        "Json?"
      }
    JsonSchema::Ref(ref_pointer) =>
      match resolver(ref_pointer) {
        Some(_resolved_schema) => {
          let last_path = ref_pointer.split("/").last()
          match last_path {
            Some(name) => name.to_string()
            None => "RefType"
          }
          // generate_mbt_types(resolved_schema, resolver~, pointer~)
        }
        None => "schema not found"
      }
    _ => "\"unsupported type\""
  }
}

///|
/// Convert to safe string for struct/variable names
fn to_symbol_name(self : JsonPointer) -> String {
  let logger : StringBuilder = StringBuilder::new()
  self.to_symbol_name_inner(logger)
  logger.to_string()
}

///|
fn to_symbol_name_inner(self : JsonPointer, logger : StringBuilder) -> Unit {
  match self {
    Root => logger.write_string("")
    Key(p, key~) => {
      logger.write_string(p.to_symbol_name())
      logger.write_string("_")
      logger.write_string(key)
    }
    Index(p, index~) =>
      logger
      ..write_string(p.to_symbol_name())
      ..write_string("_")
      ..write_string(index.to_string())
  }
}

///|
test "mbt code generation" {
  let schema : Json = @json.parse(
    (
      #|{
      #|  "type": "object",
      #|  "properties": {
      #|    "name": { "type": "string" },
      #|    "age": { "type": "number" },
      #|    "items": {
      #|      "type": "array",
      #|      "items": { "type": "string" }
      #|    },
      #|    "opt_str": {
      #|      "oneOf": [
      #|        { "type": "string" },
      #|        { "type": "null" }
      #|      ]
      #|    },
      #|    "opt_number": {
      #|      "oneOf": [
      #|        { "type": "number" },
      #|        { "type": "null" }
      #|      ]
      #|    }
      #|  },
      #|  "required": ["name", "age"]
      #|}
    ),
  )
  let jschema : JsonSchema = @json.from_json(schema)
  let code = generate_moonbit_statement(jschema, "MyStruct", resolver=fn(_s) {
    None
  })
  inspect(
    code.unwrap(),
    content=(
      #|struct MyStruct {
      #|  name: String
      #|  age: Double
      #|  items: Array[String]?
      #|  opt_str: String?
      #|  opt_number: Double?
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "mbt code generation with inner struct" {
  let schema : Json = @json.parse(
    (
      #|{
      #|  "type": "object",
      #|  "properties": {
      #|    "nested": {
      #|      "type": "object",
      #|      "required": ["id"], 
      #|      "properties": {
      #|        "id": { "type": "integer" }
      #|      }
      #|    },
      #|    "d1": {
      #|      "type": "object",
      #|      "required": ["d2"], 
      #|      "properties": {
      #|        "d2": {
      #|          "type": "object",
      #|          "required": ["d3"], 
      #|          "properties": {
      #|            "d3": { "type": "string" }
      #|          }
      #|        }
      #|      }
      #|    }
      #|  },
      #|  "required": ["nested"]
      #|}
    ),
  )
  let jschema : JsonSchema = @json.from_json(schema)
  let code = generate_moonbit_statement(jschema, "MyStruct", resolver=fn(_s) {
    None
  })
  inspect(
    code.unwrap(),
    content=(
      #|struct MyStruct {
      #|  nested: _MyStruct_nested
      #|  d1: _MyStruct_d1
      #|} derive(Show, FromJson, ToJson)
      #|struct _MyStruct_nested {
      #|  id: Int
      #|} derive(Show, FromJson, ToJson)
      #|struct _MyStruct_d1 {
      #|  d2: _MyStruct_d1_d2
      #|} derive(Show, FromJson, ToJson)
      #|struct _MyStruct_d1_d2 {
      #|  d3: String
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "mbt struct generation with ref" {
  let schema : Json = {
    "definitions": {
      "Point": {
        "type": "object",
        "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
        "required": ["x", "y"],
      },
    },
    "type": "object",
    "properties": {
      "points": { "type": "array", "items": { "$ref": "#/definitions/Point" } },
    },
    "required": ["points"],
  }
  let jschema : JsonSchema = @json.from_json(schema)
  let code = generate_moonbit_statement(jschema, "MyStruct", resolver=fn(
    pointer,
  ) {
    if pointer == "#/definitions/Point" {
      JsonSchema::object(
        properties={ "x": JsonSchema::number(), "y": JsonSchema::number() },
        required=["x", "y"],
      )
      |> Some
    } else {
      JsonSchema::any() |> Some
    }
  })
  inspect(
    code.unwrap(),
    content=(
      #|struct MyStruct {
      #|  points: Array[Point]
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "generate_mbt_code" {
  let schema : Json = {
    "definitions": {
      "Point": {
        "type": "object",
        "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
        "required": ["x", "y"],
      },
      "Point3D": {
        "type": "object",
        "properties": {
          "x": { "type": "number" },
          "y": { "type": "number" },
          "z": { "type": "number" },
        },
        "required": ["x", "y", "z"],
      },
    },
    "type": "object",
    "properties": {
      "points": { "type": "array", "items": { "$ref": "#/definitions/Point" } },
    },
    "required": ["points"],
  }
  let code = generate_moonbit(
    schema,
    [JsonPointer::Root.key("definitions").key("Point3D"), JsonPointer::Root],
    root_name="MyApp",
    include_refs=true,
  )
  inspect(
    code.unwrap(),
    content=(
      #|// Generated by jsonschema
      #|
      #|// #/definitions/Point3D
      #|struct Point3D {
      #|  x: Double
      #|  y: Double
      #|  z: Double
      #|} derive(Show, FromJson, ToJson)
      #|
      #|// #
      #|struct MyApp {
      #|  points: Array[Point]
      #|} derive(Show, FromJson, ToJson)
      #|
      #|// #/definitions/Point
      #|struct Point {
      #|  x: Double
      #|  y: Double
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}
