///|
pub fn generate_moonbit(
  raw_json : Json,
  entries : Set[JsonPointer],
  include_refs? : Bool = true,
  root_struct_name? : String = "Root",
  derives? : Array[String] = ["Show", "FromJson", "ToJson"],
  struct_prefix? : String = "",
) -> Result[String, String] {
  let logger = StringBuilder::new()
  let entries : Set[JsonPointer] = Set::copy(entries)
  if include_refs {
    for ref_expr in traverse_refs_in_json(raw_json) {
      guard JsonPointer::from_string(ref_expr) is Ok(pointer) else { continue }
      entries.add(pointer)
    }
  }
  for ref_expr in traverse_refs_in_json(raw_json) {
    guard JsonPointer::from_string(ref_expr) is Ok(pointer) else { continue }
    entries.add(pointer)
  }
  logger.write_string("// Generated by jsonschema\n")
  for entry_path in entries {
    guard entry_path.access(raw_json) is Some(json) else { continue }
    let struct_name = match entry_path {
      @jsonschema.JsonPointer::Root => root_struct_name
      @jsonschema.JsonPointer::Key(_, key~) => key
      _ => continue
    }
    let resolver = @jsonschema.build_resolver(raw_json)
    try {
      let schema : JsonSchema = @json.from_json(json)
      logger.write_string("\n// \{entry_path}\n")
      if generate_moonbit_struct(
          schema,
          struct_name,
          resolver~,
          pointer=entry_path,
          derives~,
          struct_prefix~,
        )
        is Ok(code) {
        logger.write_string(code)
      } else {
        logger.write_string("\n// skip by compile error \{entry_path}\n")
      }
    } catch {
      err => return Err("failed to parse schema at \{entry_path}: \{err}")
    }
  }
  logger.to_string() |> Ok
}

///|
fn generate_moonbit_struct(
  schema : JsonSchema,
  struct_name : String,
  resolver~ : (String) -> JsonSchema?,
  derives? : Array[String] = ["Show", "FromJson", "ToJson"],
  struct_prefix? : String = "",
  pointer? : JsonPointer = JsonPointer::Root.key(struct_name),
) -> Result[String, String] {
  match schema {
    JsonSchema::OneOf(schemas) => {
      let enum_values : Map[String, JsonSchema] = {}
      for schema in schemas {
        guard schema is JsonSchema::Object(properties=Some(properties), ..) else {
          return Err("Each schema in oneOf must be object with properties")
        }
        if !properties.contains("$tag") {
          return Err("`$tag` property is required")
        }
        // println("----oneOf schema: \{properties}")
        // println(properties.get("$tag"))
        match properties.get("$tag") {
          Some(JsonSchema::Const(String(tag_value))) =>
            enum_values.set(tag_value, schema)
          // enum_values.set(tag_value, schema)
          _ => return Err("`$tag` property is required")
        }
      }
      let logger = StringBuilder::new()
      logger.write_string("enum \{struct_name} {\n")
      for tag_value, subschema in enum_values {
        guard subschema is JsonSchema::Object(properties=Some(properties), ..) else {
          return Err("Each schema in oneOf must be object with properties")
        }
        logger.write_string("  \{tag_value}(")
        let mut first = true
        for key, prop_schema in properties {
          if key == "$tag" {
            continue
          }
          if !first {
            logger.write_string(", ")
          }
          first = false
          let subtype_code = generate_moonbit_types(
            prop_schema,
            resolver~,
            pointer=pointer.key(key),
          )
          logger.write_string("~\{key}: \{subtype_code}")
        }
        logger.write_string(")\n")
      }
      logger.write_string("}\n")
      logger.to_string() |> Ok
      // Err("`$tag` property is required")
    }

    // // check all schemas has $tag const
    // // schemas.
    // let all_have_tag = schemas.all(fn(s) {
    // Err("OneOf is not supported")
    JsonSchema::Object(properties=None, ..) =>
      return Err("properties is required")
    JsonSchema::Object(properties=Some(properties), required~, ..) => {
      let inner = StringBuilder::new()
      inner.write_string("\{struct_prefix}struct \{struct_name} {\n")
      let required_keys = if required is Some(v) {
        v |> Set::from_array
      } else {
        Set::new()
      }
      let outer = StringBuilder::new()
      for key, subschema in properties {
        // nested object
        if subschema is JsonSchema::Object(..) {
          let sub_pointer = pointer.key(key)
          let sub_struct_name = sub_pointer.to_symbol_name()
          inner.write_string("  \{key}: \{sub_struct_name}\n")
          match
            generate_moonbit_struct(
              subschema,
              sub_struct_name,
              resolver~,
              pointer=sub_pointer,
            ) {
            Err(e) => return Err(e)
            Ok(nested_code) => outer.write_string(nested_code)
          }
        } else {
          // child property
          let key_is_required = required_keys.contains(key)
          let subtype_code = generate_moonbit_types(
            subschema,
            resolver~,
            pointer=pointer.key(key),
          )
          if !key_is_required && !subtype_code.has_suffix("?") {
            inner.write_string("  \{key}: \{subtype_code}?\n")
          } else {
            inner.write_string("  \{key}: \{subtype_code}\n")
          }
        }
      }
      if derives.length() > 0 {
        let str_derives = derives.join(", ")
        inner.write_string("} derive(\{str_derives})\n")
      } else {
        inner.write_string("}\n")
      }
      inner.write_string(outer.to_string())
      inner.to_string() |> Ok
    }
    _ => "\"Not Supported\"" |> Err
  }
}

///|
fn generate_moonbit_types(
  schema : JsonSchema,
  resolver~ : (String) -> JsonSchema?,
  pointer? : JsonPointer = JsonPointer::Root,
) -> String {
  match schema {
    JsonSchema::Object(..) => return "Error: direct nested schema not supported"
    JsonSchema::Array(items~, ..) => {
      let logger = StringBuilder::new()
      logger.write_string("Array[")
      if items is Some(value) {
        logger.write_string(
          generate_moonbit_types(value, resolver~, pointer=pointer.key("index")),
        )
      } else {
        logger.write_string("Any")
      }
      logger.write_string("]")
      return logger.to_string()
    }
    JsonSchema::String(..) => "String"
    JsonSchema::Number(..) => "Double"
    JsonSchema::Integer(..) => "Int"
    JsonSchema::Boolean(..) => "Bool"
    JsonSchema::OneOf(schemas) =>
      if schemas.length() == 2 {
        match schemas {
          [JsonSchema::Null(_), other] | [other, JsonSchema::Null(_)] =>
            return generate_moonbit_types(other, resolver~, pointer~) + "?"
          _ => "Json?"
        }
      } else {
        "Json?"
      }
    JsonSchema::Ref(ref_pointer) =>
      match resolver(ref_pointer) {
        Some(_resolved_schema) => {
          let last_path = ref_pointer.split("/").last()
          match last_path {
            Some(name) => name.to_string()
            None => "RefType"
          }
          // generate_mbt_types(resolved_schema, resolver~, pointer~)
        }
        None => "schema not found"
      }
    _ => "\"unsupported type\""
  }
}

///|
/// Convert to safe string for struct/variable names
fn to_symbol_name(self : JsonPointer) -> String {
  let logger : StringBuilder = StringBuilder::new()
  self.to_symbol_name_inner(logger)
  logger.to_string()
}

///|
fn to_symbol_name_inner(self : JsonPointer, logger : StringBuilder) -> Unit {
  match self {
    Root => logger.write_string("")
    Key(p, key~) => {
      logger.write_string(p.to_symbol_name())
      logger.write_string("_")
      logger.write_string(key)
    }
    Index(p, index~) =>
      logger
      ..write_string(p.to_symbol_name())
      ..write_string("_")
      ..write_string(index.to_string())
  }
}

///|
test "mbt code generation" {
  let schema : Json = @json.parse(
    (
      #|{
      #|  "type": "object",
      #|  "properties": {
      #|    "name": { "type": "string" },
      #|    "age": { "type": "number" },
      #|    "items": {
      #|      "type": "array",
      #|      "items": { "type": "string" }
      #|    },
      #|    "opt_str": {
      #|      "oneOf": [
      #|        { "type": "string" },
      #|        { "type": "null" }
      #|      ]
      #|    },
      #|    "opt_number": {
      #|      "oneOf": [
      #|        { "type": "number" },
      #|        { "type": "null" }
      #|      ]
      #|    }
      #|  },
      #|  "required": ["name", "age"]
      #|}
    ),
  )
  let jschema : JsonSchema = @json.from_json(schema)
  let code = generate_moonbit_struct(jschema, "MyStruct", resolver=fn(_s) {
    None
  })
  inspect(
    code.unwrap(),
    content=(
      #|struct MyStruct {
      #|  name: String
      #|  age: Double
      #|  items: Array[String]?
      #|  opt_str: String?
      #|  opt_number: Double?
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "mbt code generation with inner struct" {
  let schema : Json = @json.parse(
    (
      #|{
      #|  "type": "object",
      #|  "properties": {
      #|    "nested": {
      #|      "type": "object",
      #|      "required": ["id"], 
      #|      "properties": {
      #|        "id": { "type": "integer" }
      #|      }
      #|    },
      #|    "d1": {
      #|      "type": "object",
      #|      "required": ["d2"], 
      #|      "properties": {
      #|        "d2": {
      #|          "type": "object",
      #|          "required": ["d3"], 
      #|          "properties": {
      #|            "d3": { "type": "string" }
      #|          }
      #|        }
      #|      }
      #|    }
      #|  },
      #|  "required": ["nested"]
      #|}
    ),
  )
  let jschema : JsonSchema = @json.from_json(schema)
  let code = generate_moonbit_struct(jschema, "MyStruct", resolver=fn(_s) {
    None
  })
  inspect(
    code.unwrap(),
    content=(
      #|struct MyStruct {
      #|  nested: _MyStruct_nested
      #|  d1: _MyStruct_d1
      #|} derive(Show, FromJson, ToJson)
      #|struct _MyStruct_nested {
      #|  id: Int
      #|} derive(Show, FromJson, ToJson)
      #|struct _MyStruct_d1 {
      #|  d2: _MyStruct_d1_d2
      #|} derive(Show, FromJson, ToJson)
      #|struct _MyStruct_d1_d2 {
      #|  d3: String
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "mbt struct generation with ref" {
  let schema : Json = {
    "definitions": {
      "Point": {
        "type": "object",
        "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
        "required": ["x", "y"],
      },
    },
    "type": "object",
    "properties": {
      "points": { "type": "array", "items": { "$ref": "#/definitions/Point" } },
    },
    "required": ["points"],
  }
  let jschema : JsonSchema = @json.from_json(schema)
  let code = generate_moonbit_struct(jschema, "MyStruct", resolver=fn(pointer) {
    if pointer == "#/definitions/Point" {
      JsonSchema::object(
        properties={ "x": JsonSchema::number(), "y": JsonSchema::number() },
        required=["x", "y"],
      )
      |> Some
    } else {
      JsonSchema::any() |> Some
    }
  })
  inspect(
    code.unwrap(),
    content=(
      #|struct MyStruct {
      #|  points: Array[Point]
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}

///|
test "$tag special case: oneOf to enum union types" {
  let raw : Json = {
    "oneOf": [
      {
        "type": "object",
        "required": ["$tag", "x"],
        "properties": { "$tag": { "const": "A" }, "a": { "type": "number" } },
      },
      {
        "type": "object",
        "properties": { "$tag": { "const": "B" }, "b": { "type": "string" } },
      },
    ],
  }
  let schema : JsonSchema = @json.from_json(raw)
  let code = generate_moonbit_struct(schema, "MyEnum", resolver=fn(_) { None })
  inspect(
    // code,
    code.unwrap(),
    content=(
      #|enum MyEnum {
      #|  A(~a: Double)
      #|  B(~b: String)
      #|}
      #|
    ),
  )
}

///|
test "generate_mbt_code" {
  let schema : Json = {
    "definitions": {
      "Point": {
        "type": "object",
        "properties": { "x": { "type": "number" }, "y": { "type": "number" } },
        "required": ["x", "y"],
      },
      "Point3D": {
        "type": "object",
        "properties": {
          "x": { "type": "number" },
          "y": { "type": "number" },
          "z": { "type": "number" },
        },
        "required": ["x", "y", "z"],
      },
    },
    "type": "object",
    "properties": {
      "points": { "type": "array", "items": { "$ref": "#/definitions/Point" } },
    },
    "required": ["points"],
  }
  let code = generate_moonbit(
    schema,
    Set::from_array([
      JsonPointer::Root.key("definitions").key("Point3D"),
      JsonPointer::Root,
    ]),
    root_struct_name="MyApp",
    derives=["Show", "FromJson", "ToJson"],
    include_refs=true,
  )
  inspect(
    code.unwrap(),
    content=(
      #|// Generated by jsonschema
      #|
      #|// #/definitions/Point3D
      #|struct Point3D {
      #|  x: Double
      #|  y: Double
      #|  z: Double
      #|} derive(Show, FromJson, ToJson)
      #|
      #|// #
      #|struct MyApp {
      #|  points: Array[Point]
      #|} derive(Show, FromJson, ToJson)
      #|
      #|// #/definitions/Point
      #|struct Point {
      #|  x: Double
      #|  y: Double
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}
