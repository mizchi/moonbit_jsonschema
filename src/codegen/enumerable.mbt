// typealias @jsonschema.

///|
fn render_enumerable_one_of(
  enum_name : String,
  enum_items : Array[@jsonschema.EnumerableOneOf],
  prefix~ : String,
  resolver~ : @jsonschema.Resolver,
  pointer~ : JsonPointer,
) -> String {
  let logger = StringBuilder::new()
  logger..write_string(prefix)..write_string("enum \{enum_name} {")
  for subschema in enum_items {
    // Tag
    let has_args = subschema.positionals.length() > 0 ||
      subschema.params is Some(_)
    if !has_args {
      logger.write_string("\n  \{subschema.tag}")
      continue
    }
    // Tag(
    logger.write_string("\n  \{subschema.tag}(")
    for s in subschema.positionals {
      let subtype_code = generate_type_expr(
        s,
        resolver~,
        pointer=pointer.key(subschema.tag).index(0),
      )
      logger.write_string(subtype_code)
    }

    // Tag(A, ~param: V,
    if subschema.params is Some(JsonSchema::Object(properties=Some(params), ..)) {
      let codes = params.map(fn(key, prop_schema) {
        let subtype_code = generate_type_expr(
          prop_schema,
          resolver~,
          pointer=pointer.key(key),
        )
        "~\{key}: \{subtype_code}"
      })
      logger.write_string(codes.values().to_array().join(", "))
    }
    logger.write_string(")")
  }
  logger.write_string("\n} derive(Show, Eq, FromJson, ToJson)\n")
  logger.to_string()
}

///|
test "Parse [tagKey, {...}] for moonbit enum" {
  let raw : Json = {
    "definitions": { "Num": { "type": "integer" } },
    "oneOf": [
      // A(~a: Double, ~b: String)
      {
        "type": "array",
        "prefixItems": [
          { "const": "A" },
          {
            "type": "object",
            "required": ["a", "b"],
            "properties": {
              "a": { "type": "number" },
              "b": { "type": "string" },
            },
          },
        ],
      },
      // B
      { "type": "array", "prefixItems": [{ "const": "B" }] },
      // C
      { "type": "array", "prefixItems": [{ "const": "C" }] },
      // X(Num)
      {
        "type": "array",
        "prefixItems": [{ "const": "X" }, { "$ref": "#/definitions/Num" }],
      },
    ],
  }
  // let schema : JsonSchema = @json.from_json(raw)
  let code = generate(
    raw,
    [JsonPointer::Root],
    root_name="MyEnum",
    prefix="pub ",
  )
  inspect(
    // code,
    code.unwrap(),
    content=(
      #|// Generated by jsonschema
      #|
      #|// #
      #|pub enum MyEnum {
      #|  A(~a: Double, ~b: String)
      #|  B
      #|  C
      #|  X(Num)
      #|} derive(Show, Eq, FromJson, ToJson)
      #|
      #|// #/definitions/Num
      #|pub struct Num(Int) derive(Show, Eq, FromJson, ToJson)
    ),
  )
}

///|
test "all refs in oneOf to enum union types" {
  let raw : Json = {
    "definitions": {
      "A": { "type": "object", "properties": { "a": { "type": "number" } } },
      "B": { "type": "object", "properties": { "b": { "type": "string" } } },
    },
    "oneOf": [
      {
        "type": "array",
        "prefixItems": [{ "const": "A" }, { "$ref": "#/definitions/A" }],
      },
      {
        "type": "array",
        "prefixItems": [{ "const": "B" }, { "$ref": "#/definitions/B" }],
      },
    ],
  }
  // let schema : JsonSchema = @json.from_json(raw)
  let code = generate(
    raw,
    [JsonPointer::Root],
    root_name="MyEnum",
    prefix="pub ",
  )
  inspect(
    // code,
    code.unwrap(),
    content=(
      #|// Generated by jsonschema
      #|
      #|// #
      #|pub enum MyEnum {
      #|  A(A)
      #|  B(B)
      #|} derive(Show, Eq, FromJson, ToJson)
      #|
      #|// #/definitions/A
      #|pub struct A {
      #|  a: Double?
      #|} derive(Show, FromJson, ToJson)
      #|
      #|// #/definitions/B
      #|pub struct B {
      #|  b: String?
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}
