// typealias @jsonschema.

///|
priv struct EnumerableOneOf {
  tag : String
  positionals : Array[JsonSchema]
  params : JsonSchema?
}

///|
fn parse_enumerable_one_of(schema : JsonSchema) -> Array[EnumerableOneOf]? {
  guard schema is JsonSchema::OneOf(schemas) else { return None }
  guard schemas.get(0) is Some(first_schema) else { return None }
  // prefixItems case
  if first_schema
    is JsonSchema::Array(
      prefixItems=Some([JsonSchema::Const(String(_)), ..]),
      ..
    ) {
    let parsed : Array[EnumerableOneOf] = []
    for schema in schemas {
      match schema {
        // [{"const": "A"}]
        JsonSchema::Array(
          prefixItems=Some([JsonSchema::Const(String(tag_value))]),
          ..
        ) =>
          parsed.push(EnumerableOneOf::{
            tag: tag_value,
            positionals: [],
            params: None,
          })
        // [{"const": "A"}, ..]
        JsonSchema::Array(
          prefixItems=Some(
            [JsonSchema::Const(String(tag_value)), .. child_schemas]
          ),
          ..
        ) => {
          let matched = match child_schemas.to_array() {
            [] => { tag: tag_value, positionals: [], params: None }
            [.. positionals, JsonSchema::Object(_) as params] =>
              {
                tag: tag_value,
                positionals: positionals.to_array(),
                params: Some(params),
              }
            [.. positionals] =>
              {
                tag: tag_value,
                positionals: positionals.to_array(),
                params: None,
              }
          }
          parsed.push(matched)
        }
        _ => ()
      }
    }
    return Some(parsed)
  }
  None
}

///|
fn render_enumerable_one_of(
  enum_name : String,
  enum_items : Array[EnumerableOneOf],
  prefix~ : String,
  resolver~ : (String) -> JsonSchema?,
  pointer~ : JsonPointer,
) -> String {
  let logger = StringBuilder::new()
  logger..write_string(prefix)..write_string("enum \{enum_name} {")
  for subschema in enum_items {
    // Tag
    let has_args = subschema.positionals.length() > 0 ||
      subschema.params is Some(_)
    if !has_args {
      logger.write_string("\n  \{subschema.tag}")
      continue
    }
    // Tag(
    logger.write_string("\n  \{subschema.tag}(")
    for s in subschema.positionals {
      let subtype_code = generate_type_expr(
        s,
        resolver~,
        pointer=pointer.key(subschema.tag).index(0),
      )
      logger.write_string(subtype_code)
    }

    // Tag(A, ~param: V,
    if subschema.params is Some(JsonSchema::Object(properties=Some(params), ..)) {
      let codes = params.map(fn(key, prop_schema) {
        let subtype_code = generate_type_expr(
          prop_schema,
          resolver~,
          pointer=pointer.key(key),
        )
        "~\{key}: \{subtype_code}"
      })
      logger.write_string(codes.values().to_array().join(", "))
    }
    logger.write_string(")")
  }
  logger.write_string("\n} derive(Show, Eq, FromJson, ToJson)\n")
  logger.to_string()
}

///|
test "Parse [tagKey, {...}] for moonbit enum" {
  let raw : Json = {
    "definitions": { "Num": { "type": "integer" } },
    "oneOf": [
      // A(~a: Double, ~b: String)
      {
        "type": "array",
        "prefixItems": [
          { "const": "A" },
          {
            "type": "object",
            "required": ["a", "b"],
            "properties": {
              "a": { "type": "number" },
              "b": { "type": "string" },
            },
          },
        ],
      },
      // B
      { "type": "array", "prefixItems": [{ "const": "B" }] },
      // C
      { "type": "array", "prefixItems": [{ "const": "C" }] },
      // X(Num)
      {
        "type": "array",
        "prefixItems": [{ "const": "X" }, { "$ref": "#/definitions/Num" }],
      },
    ],
  }
  // let schema : JsonSchema = @json.from_json(raw)
  let code = generate_moonbit(
    raw,
    [JsonPointer::Root],
    root_name="MyEnum",
    prefix="pub ",
  )
  inspect(
    // code,
    code.unwrap(),
    content=(
      #|// Generated by jsonschema
      #|
      #|// #
      #|pub enum MyEnum {
      #|  A(~a: Double, ~b: String)
      #|  B
      #|  C
      #|  X(Num)
      #|} derive(Show, Eq, FromJson, ToJson)
      #|
      #|// #/definitions/Num
      #|pub struct Num(Int) derive(Show, Eq, FromJson, ToJson)
    ),
  )
}

///|
test "all refs in oneOf to enum union types" {
  let raw : Json = {
    "definitions": {
      "A": { "type": "object", "properties": { "a": { "type": "number" } } },
      "B": { "type": "object", "properties": { "b": { "type": "string" } } },
    },
    "oneOf": [
      {
        "type": "array",
        "prefixItems": [{ "const": "A" }, { "$ref": "#/definitions/A" }],
      },
      {
        "type": "array",
        "prefixItems": [{ "const": "B" }, { "$ref": "#/definitions/B" }],
      },
    ],
  }
  // let schema : JsonSchema = @json.from_json(raw)
  let code = generate_moonbit(
    raw,
    [JsonPointer::Root],
    root_name="MyEnum",
    prefix="pub ",
  )
  inspect(
    // code,
    code.unwrap(),
    content=(
      #|// Generated by jsonschema
      #|
      #|// #
      #|pub enum MyEnum {
      #|  A(A)
      #|  B(B)
      #|} derive(Show, Eq, FromJson, ToJson)
      #|
      #|// #/definitions/A
      #|pub struct A {
      #|  a: Double?
      #|} derive(Show, FromJson, ToJson)
      #|
      #|// #/definitions/B
      #|pub struct B {
      #|  b: String?
      #|} derive(Show, FromJson, ToJson)
      #|
    ),
  )
}
